var batchManagementClient =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 3);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const ms_rest_azure_js_1 = __webpack_require__(2);
exports.CloudError = ms_rest_azure_js_1.CloudErrorMapper;
exports.BaseResource = ms_rest_azure_js_1.BaseResourceMapper;
exports.AutoStorageBaseProperties = {
    required: false,
    serializedName: 'AutoStorageBaseProperties',
    type: {
        name: 'Composite',
        className: 'AutoStorageBaseProperties',
        modelProperties: {
            storageAccountId: {
                required: true,
                serializedName: 'storageAccountId',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
exports.KeyVaultReference = {
    required: false,
    serializedName: 'KeyVaultReference',
    type: {
        name: 'Composite',
        className: 'KeyVaultReference',
        modelProperties: {
            id: {
                required: true,
                serializedName: 'id',
                type: {
                    name: 'String'
                }
            },
            url: {
                required: true,
                serializedName: 'url',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
exports.BatchAccountCreateParameters = {
    required: false,
    serializedName: 'BatchAccountCreateParameters',
    type: {
        name: 'Composite',
        className: 'BatchAccountCreateParameters',
        modelProperties: {
            location: {
                required: true,
                serializedName: 'location',
                type: {
                    name: 'String'
                }
            },
            tags: {
                required: false,
                serializedName: 'tags',
                type: {
                    name: 'Dictionary',
                    value: {
                        required: false,
                        serializedName: 'stringElementType',
                        type: {
                            name: 'String'
                        }
                    }
                }
            },
            autoStorage: {
                required: false,
                serializedName: 'properties.autoStorage',
                type: {
                    name: 'Composite',
                    className: 'AutoStorageBaseProperties'
                }
            },
            poolAllocationMode: {
                required: false,
                serializedName: 'properties.poolAllocationMode',
                type: {
                    name: 'Enum',
                    allowedValues: ['BatchService', 'UserSubscription']
                }
            },
            keyVaultReference: {
                required: false,
                serializedName: 'properties.keyVaultReference',
                type: {
                    name: 'Composite',
                    className: 'KeyVaultReference'
                }
            }
        }
    }
};
exports.AutoStorageProperties = {
    required: false,
    serializedName: 'AutoStorageProperties',
    type: {
        name: 'Composite',
        className: 'AutoStorageProperties',
        modelProperties: {
            storageAccountId: {
                required: true,
                serializedName: 'storageAccountId',
                type: {
                    name: 'String'
                }
            },
            lastKeySync: {
                required: true,
                serializedName: 'lastKeySync',
                type: {
                    name: 'DateTime'
                }
            }
        }
    }
};
exports.Resource = {
    required: false,
    serializedName: 'Resource',
    type: {
        name: 'Composite',
        className: 'Resource',
        modelProperties: {
            id: {
                required: false,
                readOnly: true,
                serializedName: 'id',
                type: {
                    name: 'String'
                }
            },
            name: {
                required: false,
                readOnly: true,
                serializedName: 'name',
                type: {
                    name: 'String'
                }
            },
            type: {
                required: false,
                readOnly: true,
                serializedName: 'type',
                type: {
                    name: 'String'
                }
            },
            location: {
                required: false,
                readOnly: true,
                serializedName: 'location',
                type: {
                    name: 'String'
                }
            },
            tags: {
                required: false,
                readOnly: true,
                serializedName: 'tags',
                type: {
                    name: 'Dictionary',
                    value: {
                        required: false,
                        serializedName: 'stringElementType',
                        type: {
                            name: 'String'
                        }
                    }
                }
            }
        }
    }
};
exports.BatchAccount = {
    required: false,
    serializedName: 'BatchAccount',
    type: {
        name: 'Composite',
        className: 'BatchAccount',
        modelProperties: {
            id: {
                required: false,
                readOnly: true,
                serializedName: 'id',
                type: {
                    name: 'String'
                }
            },
            name: {
                required: false,
                readOnly: true,
                serializedName: 'name',
                type: {
                    name: 'String'
                }
            },
            type: {
                required: false,
                readOnly: true,
                serializedName: 'type',
                type: {
                    name: 'String'
                }
            },
            location: {
                required: false,
                readOnly: true,
                serializedName: 'location',
                type: {
                    name: 'String'
                }
            },
            tags: {
                required: false,
                readOnly: true,
                serializedName: 'tags',
                type: {
                    name: 'Dictionary',
                    value: {
                        required: false,
                        serializedName: 'stringElementType',
                        type: {
                            name: 'String'
                        }
                    }
                }
            },
            accountEndpoint: {
                required: false,
                readOnly: true,
                serializedName: 'properties.accountEndpoint',
                type: {
                    name: 'String'
                }
            },
            provisioningState: {
                required: false,
                readOnly: true,
                serializedName: 'properties.provisioningState',
                type: {
                    name: 'Enum',
                    allowedValues: ['Invalid', 'Creating', 'Deleting', 'Succeeded', 'Failed', 'Cancelled']
                }
            },
            poolAllocationMode: {
                required: false,
                readOnly: true,
                serializedName: 'properties.poolAllocationMode',
                type: {
                    name: 'Enum',
                    allowedValues: ['BatchService', 'UserSubscription']
                }
            },
            keyVaultReference: {
                required: false,
                readOnly: true,
                serializedName: 'properties.keyVaultReference',
                type: {
                    name: 'Composite',
                    className: 'KeyVaultReference'
                }
            },
            autoStorage: {
                required: false,
                readOnly: true,
                serializedName: 'properties.autoStorage',
                type: {
                    name: 'Composite',
                    className: 'AutoStorageProperties'
                }
            },
            dedicatedCoreQuota: {
                required: false,
                readOnly: true,
                serializedName: 'properties.dedicatedCoreQuota',
                type: {
                    name: 'Number'
                }
            },
            lowPriorityCoreQuota: {
                required: false,
                readOnly: true,
                serializedName: 'properties.lowPriorityCoreQuota',
                type: {
                    name: 'Number'
                }
            },
            poolQuota: {
                required: false,
                readOnly: true,
                serializedName: 'properties.poolQuota',
                type: {
                    name: 'Number'
                }
            },
            activeJobAndJobScheduleQuota: {
                required: false,
                readOnly: true,
                serializedName: 'properties.activeJobAndJobScheduleQuota',
                type: {
                    name: 'Number'
                }
            }
        }
    }
};
exports.BatchAccountUpdateParameters = {
    required: false,
    serializedName: 'BatchAccountUpdateParameters',
    type: {
        name: 'Composite',
        className: 'BatchAccountUpdateParameters',
        modelProperties: {
            tags: {
                required: false,
                serializedName: 'tags',
                type: {
                    name: 'Dictionary',
                    value: {
                        required: false,
                        serializedName: 'stringElementType',
                        type: {
                            name: 'String'
                        }
                    }
                }
            },
            autoStorage: {
                required: false,
                serializedName: 'properties.autoStorage',
                type: {
                    name: 'Composite',
                    className: 'AutoStorageBaseProperties'
                }
            }
        }
    }
};
exports.BatchAccountRegenerateKeyParameters = {
    required: false,
    serializedName: 'BatchAccountRegenerateKeyParameters',
    type: {
        name: 'Composite',
        className: 'BatchAccountRegenerateKeyParameters',
        modelProperties: {
            keyName: {
                required: true,
                serializedName: 'keyName',
                type: {
                    name: 'Enum',
                    allowedValues: ['Primary', 'Secondary']
                }
            }
        }
    }
};
exports.BatchAccountKeys = {
    required: false,
    serializedName: 'BatchAccountKeys',
    type: {
        name: 'Composite',
        className: 'BatchAccountKeys',
        modelProperties: {
            accountName: {
                required: false,
                readOnly: true,
                serializedName: 'accountName',
                type: {
                    name: 'String'
                }
            },
            primary: {
                required: false,
                readOnly: true,
                serializedName: 'primary',
                type: {
                    name: 'String'
                }
            },
            secondary: {
                required: false,
                readOnly: true,
                serializedName: 'secondary',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
exports.ActivateApplicationPackageParameters = {
    required: false,
    serializedName: 'ActivateApplicationPackageParameters',
    type: {
        name: 'Composite',
        className: 'ActivateApplicationPackageParameters',
        modelProperties: {
            format: {
                required: true,
                serializedName: 'format',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
exports.ApplicationCreateParameters = {
    required: false,
    serializedName: 'ApplicationCreateParameters',
    type: {
        name: 'Composite',
        className: 'ApplicationCreateParameters',
        modelProperties: {
            allowUpdates: {
                required: false,
                serializedName: 'allowUpdates',
                type: {
                    name: 'Boolean'
                }
            },
            displayName: {
                required: false,
                serializedName: 'displayName',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
exports.ApplicationPackage = {
    required: false,
    serializedName: 'ApplicationPackage',
    type: {
        name: 'Composite',
        className: 'ApplicationPackage',
        modelProperties: {
            id: {
                required: false,
                readOnly: true,
                serializedName: 'id',
                type: {
                    name: 'String'
                }
            },
            version: {
                required: false,
                readOnly: true,
                serializedName: 'version',
                type: {
                    name: 'String'
                }
            },
            state: {
                required: false,
                readOnly: true,
                serializedName: 'state',
                type: {
                    name: 'Enum',
                    allowedValues: ['pending', 'active', 'unmapped']
                }
            },
            format: {
                required: false,
                readOnly: true,
                serializedName: 'format',
                type: {
                    name: 'String'
                }
            },
            storageUrl: {
                required: false,
                readOnly: true,
                serializedName: 'storageUrl',
                type: {
                    name: 'String'
                }
            },
            storageUrlExpiry: {
                required: false,
                readOnly: true,
                serializedName: 'storageUrlExpiry',
                type: {
                    name: 'DateTime'
                }
            },
            lastActivationTime: {
                required: false,
                readOnly: true,
                serializedName: 'lastActivationTime',
                type: {
                    name: 'DateTime'
                }
            }
        }
    }
};
exports.Application = {
    required: false,
    serializedName: 'Application',
    type: {
        name: 'Composite',
        className: 'Application',
        modelProperties: {
            id: {
                required: false,
                serializedName: 'id',
                type: {
                    name: 'String'
                }
            },
            displayName: {
                required: false,
                serializedName: 'displayName',
                type: {
                    name: 'String'
                }
            },
            packages: {
                required: false,
                serializedName: 'packages',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'ApplicationPackageElementType',
                        type: {
                            name: 'Composite',
                            className: 'ApplicationPackage'
                        }
                    }
                }
            },
            allowUpdates: {
                required: false,
                serializedName: 'allowUpdates',
                type: {
                    name: 'Boolean'
                }
            },
            defaultVersion: {
                required: false,
                serializedName: 'defaultVersion',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
exports.ApplicationUpdateParameters = {
    required: false,
    serializedName: 'ApplicationUpdateParameters',
    type: {
        name: 'Composite',
        className: 'ApplicationUpdateParameters',
        modelProperties: {
            allowUpdates: {
                required: false,
                serializedName: 'allowUpdates',
                type: {
                    name: 'Boolean'
                }
            },
            defaultVersion: {
                required: false,
                serializedName: 'defaultVersion',
                type: {
                    name: 'String'
                }
            },
            displayName: {
                required: false,
                serializedName: 'displayName',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
exports.BatchLocationQuota = {
    required: false,
    serializedName: 'BatchLocationQuota',
    type: {
        name: 'Composite',
        className: 'BatchLocationQuota',
        modelProperties: {
            accountQuota: {
                required: false,
                readOnly: true,
                serializedName: 'accountQuota',
                type: {
                    name: 'Number'
                }
            }
        }
    }
};
exports.OperationDisplay = {
    required: false,
    serializedName: 'Operation_display',
    type: {
        name: 'Composite',
        className: 'OperationDisplay',
        modelProperties: {
            provider: {
                required: false,
                serializedName: 'provider',
                type: {
                    name: 'String'
                }
            },
            operation: {
                required: false,
                serializedName: 'operation',
                type: {
                    name: 'String'
                }
            },
            resource: {
                required: false,
                serializedName: 'resource',
                type: {
                    name: 'String'
                }
            },
            description: {
                required: false,
                serializedName: 'description',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
exports.Operation = {
    required: false,
    serializedName: 'Operation',
    type: {
        name: 'Composite',
        className: 'Operation',
        modelProperties: {
            name: {
                required: false,
                serializedName: 'name',
                type: {
                    name: 'String'
                }
            },
            display: {
                required: false,
                serializedName: 'display',
                type: {
                    name: 'Composite',
                    className: 'OperationDisplay'
                }
            },
            origin: {
                required: false,
                serializedName: 'origin',
                type: {
                    name: 'String'
                }
            },
            properties: {
                required: false,
                serializedName: 'properties',
                type: {
                    name: 'Object'
                }
            }
        }
    }
};
exports.CheckNameAvailabilityParameters = {
    required: false,
    serializedName: 'CheckNameAvailabilityParameters',
    type: {
        name: 'Composite',
        className: 'CheckNameAvailabilityParameters',
        modelProperties: {
            name: {
                required: true,
                serializedName: 'name',
                type: {
                    name: 'String'
                }
            },
            type: {
                required: true,
                isConstant: true,
                serializedName: 'type',
                defaultValue: 'Microsoft.Batch/batchAccounts',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
exports.CheckNameAvailabilityResult = {
    required: false,
    serializedName: 'CheckNameAvailabilityResult',
    type: {
        name: 'Composite',
        className: 'CheckNameAvailabilityResult',
        modelProperties: {
            nameAvailable: {
                required: false,
                readOnly: true,
                serializedName: 'nameAvailable',
                type: {
                    name: 'Boolean'
                }
            },
            reason: {
                required: false,
                readOnly: true,
                serializedName: 'reason',
                type: {
                    name: 'Enum',
                    allowedValues: ['Invalid', 'AlreadyExists']
                }
            },
            message: {
                required: false,
                readOnly: true,
                serializedName: 'message',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
exports.ApplicationCreateOptionalParams = {
    required: false,
    serializedName: 'CreateOptions',
    type: {
        name: 'Composite',
        className: 'ApplicationCreateOptionalParams',
        modelProperties: {
            parameters: {
                required: false,
                serializedName: 'parameters',
                type: {
                    name: 'Composite',
                    className: 'ApplicationCreateParameters'
                }
            }
        }
    }
};
exports.ApplicationListOptionalParams = {
    required: false,
    serializedName: 'ListOptions',
    type: {
        name: 'Composite',
        className: 'ApplicationListOptionalParams',
        modelProperties: {
            maxresults: {
                required: false,
                serializedName: 'maxresults',
                type: {
                    name: 'Number'
                }
            }
        }
    }
};
exports.BatchAccountListResult = {
    required: false,
    serializedName: 'BatchAccountListResult',
    type: {
        name: 'Composite',
        className: 'BatchAccountListResult',
        modelProperties: {
            value: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'BatchAccountElementType',
                        type: {
                            name: 'Composite',
                            className: 'BatchAccount'
                        }
                    }
                }
            },
            nextLink: {
                required: false,
                serializedName: 'nextLink',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
exports.ListApplicationsResult = {
    required: false,
    serializedName: 'ListApplicationsResult',
    type: {
        name: 'Composite',
        className: 'ListApplicationsResult',
        modelProperties: {
            value: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'ApplicationElementType',
                        type: {
                            name: 'Composite',
                            className: 'Application'
                        }
                    }
                }
            },
            nextLink: {
                required: false,
                serializedName: 'nextLink',
                type: {
                    name: 'String'
                }
            }
        }
    }
};
exports.OperationListResult = {
    required: false,
    serializedName: 'OperationListResult',
    type: {
        name: 'Composite',
        className: 'OperationListResult',
        modelProperties: {
            value: {
                required: false,
                serializedName: '',
                type: {
                    name: 'Sequence',
                    element: {
                        required: false,
                        serializedName: 'OperationElementType',
                        type: {
                            name: 'Composite',
                            className: 'Operation'
                        }
                    }
                }
            },
            nextLink: {
                required: false,
                serializedName: 'nextLink',
                type: {
                    name: 'String'
                }
            }
        }
    }
};


/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = msRest;

/***/ }),
/* 2 */
/***/ (function(module, exports) {

module.exports = msRestAzure;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const Models = __webpack_require__(4);
exports.BatchManagementModels = Models;
const Mappers = __webpack_require__(0);
exports.BatchManagementMappers = Mappers;
const msRest = __webpack_require__(1);
const msRestAzure = __webpack_require__(2);
const operations = __webpack_require__(5);
const packageName = "azure-arm-batch-js";
const packageVersion = "0.1.0";
class BatchManagementClient extends msRestAzure.AzureServiceClient {
    /**
     * @class
     * Initializes a new instance of the BatchManagementClient class.
     * @constructor
     *
     * @param {msRest.ServiceClientCredentials} credentials - Credentials needed for the client to connect to Azure.
     *
     * @param {string} subscriptionId - The Azure subscription ID. This is a GUID-formatted string (e.g. 00000000-0000-0000-0000-000000000000)
     *
     * @param {string} [baseUri] - The base URI of the service.
     *
     * @param {object} [options] - The parameter options
     *
     * @param {Array} [options.filters] - Filters to be added to the request pipeline
     *
     * @param {object} [options.requestOptions] - The request options. Detailed info can be found at
     * {@link https://github.github.io/fetch/#Request Options doc}
     *
     * @param {boolean} [options.noRetryPolicy] - If set to true, turn off default retry policy
     *
     * @param {string} [options.acceptLanguage] - Gets or sets the preferred language for the response.
     *
     * @param {number} [options.longRunningOperationRetryTimeout] - Gets or sets the retry timeout in seconds for Long Running Operations. Default value is 30.
     *
     * @param {boolean} [options.generateClientRequestId] - When set to true a unique x-ms-client-request-id value is generated and included in each request. Default is true.
     *
     */
    constructor(credentials, subscriptionId, baseUri, options) {
        if (credentials === null || credentials === undefined) {
            throw new Error('\'credentials\' cannot be null.');
        }
        if (subscriptionId === null || subscriptionId === undefined) {
            throw new Error('\'subscriptionId\' cannot be null.');
        }
        if (!options)
            options = {};
        super(credentials, options);
        this.apiVersion = '2017-05-01';
        this.acceptLanguage = 'en-US';
        this.longRunningOperationRetryTimeout = 30;
        this.generateClientRequestId = true;
        this.baseUri = baseUri;
        if (!this.baseUri) {
            this.baseUri = 'https://management.azure.com';
        }
        this.credentials = credentials;
        this.subscriptionId = subscriptionId;
        this.addUserAgentInfo(`${packageName}/${packageVersion}`);
        if (options.acceptLanguage !== null && options.acceptLanguage !== undefined) {
            this.acceptLanguage = options.acceptLanguage;
        }
        if (options.longRunningOperationRetryTimeout !== null && options.longRunningOperationRetryTimeout !== undefined) {
            this.longRunningOperationRetryTimeout = options.longRunningOperationRetryTimeout;
        }
        if (options.generateClientRequestId !== null && options.generateClientRequestId !== undefined) {
            this.generateClientRequestId = options.generateClientRequestId;
        }
        this.batchAccount = new operations.BatchAccountOperations(this);
        this.applicationPackage = new operations.ApplicationPackageOperations(this);
        this.application = new operations.ApplicationOperations(this);
        this.location = new operations.Location(this);
        this.operations = new operations.Operations(this);
        this.serializer = new msRest.Serializer(Mappers);
    }
}
exports.BatchManagementClient = BatchManagementClient;


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Defines values for PoolAllocationMode.
 * Possible values include: 'BatchService', 'UserSubscription'
 * @readonly
 * @enum {string}
 */
var PoolAllocationMode;
(function (PoolAllocationMode) {
    PoolAllocationMode["BatchService"] = "BatchService";
    PoolAllocationMode["UserSubscription"] = "UserSubscription";
})(PoolAllocationMode = exports.PoolAllocationMode || (exports.PoolAllocationMode = {}));
/**
 * Defines values for ProvisioningState.
 * Possible values include: 'Invalid', 'Creating', 'Deleting', 'Succeeded',
 * 'Failed', 'Cancelled'
 * @readonly
 * @enum {string}
 */
var ProvisioningState;
(function (ProvisioningState) {
    ProvisioningState["Invalid"] = "Invalid";
    ProvisioningState["Creating"] = "Creating";
    ProvisioningState["Deleting"] = "Deleting";
    ProvisioningState["Succeeded"] = "Succeeded";
    ProvisioningState["Failed"] = "Failed";
    ProvisioningState["Cancelled"] = "Cancelled";
})(ProvisioningState = exports.ProvisioningState || (exports.ProvisioningState = {}));
/**
 * Defines values for AccountKeyType.
 * Possible values include: 'Primary', 'Secondary'
 * @readonly
 * @enum {string}
 */
var AccountKeyType;
(function (AccountKeyType) {
    AccountKeyType["Primary"] = "Primary";
    AccountKeyType["Secondary"] = "Secondary";
})(AccountKeyType = exports.AccountKeyType || (exports.AccountKeyType = {}));
/**
 * Defines values for PackageState.
 * Possible values include: 'pending', 'active', 'unmapped'
 * @readonly
 * @enum {string}
 */
var PackageState;
(function (PackageState) {
    PackageState["Pending"] = "pending";
    PackageState["Active"] = "active";
    PackageState["Unmapped"] = "unmapped";
})(PackageState = exports.PackageState || (exports.PackageState = {}));
/**
 * Defines values for NameAvailabilityReason.
 * Possible values include: 'Invalid', 'AlreadyExists'
 * @readonly
 * @enum {string}
 */
var NameAvailabilityReason;
(function (NameAvailabilityReason) {
    NameAvailabilityReason["Invalid"] = "Invalid";
    NameAvailabilityReason["AlreadyExists"] = "AlreadyExists";
})(NameAvailabilityReason = exports.NameAvailabilityReason || (exports.NameAvailabilityReason = {}));


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const batchAccountOperations_1 = __webpack_require__(6);
exports.BatchAccountOperations = batchAccountOperations_1.BatchAccountOperations;
const applicationPackageOperations_1 = __webpack_require__(7);
exports.ApplicationPackageOperations = applicationPackageOperations_1.ApplicationPackageOperations;
const applicationOperations_1 = __webpack_require__(8);
exports.ApplicationOperations = applicationOperations_1.ApplicationOperations;
const location_1 = __webpack_require__(9);
exports.Location = location_1.Location;
const operations_1 = __webpack_require__(10);
exports.Operations = operations_1.Operations;


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const msRest = __webpack_require__(1);
const Mappers = __webpack_require__(0);
const WebResource = msRest.WebResource;
/** Class representing a BatchAccountOperations. */
class BatchAccountOperations {
    /**
     * Create a BatchAccountOperations.
     * @param {BatchManagementClient} client Reference to the service client.
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Creates a new Batch account with the specified parameters. Existing accounts
     * cannot be updated with this API and should instead be updated with the
     * Update Batch Account API.
     *
     * @param {string} resourceGroupName The name of the resource group that
     * contains the Batch account.
     *
     * @param {string} accountName A name for the Batch account which must be
     * unique within the region. Batch account names must be between 3 and 24
     * characters in length and must use only numbers and lowercase letters. This
     * name is used as part of the DNS name that is used to access the Batch
     * service in the region in which the account is created. For example:
     * http://accountname.region.batch.azure.com/.
     *
     * @param {BatchAccountCreateParameters} parameters Additional parameters for
     * account creation.
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    createWithHttpOperationResponse(resourceGroupName, accountName, parameters, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            // Send request
            let initialResult;
            try {
                initialResult = yield this.beginCreateWithHttpOperationResponse(resourceGroupName, accountName, parameters, options);
            }
            catch (err) {
                return Promise.reject(err);
            }
            let operationRes;
            try {
                operationRes = yield client.getLongRunningOperationResult(initialResult, options);
                let httpRequest = operationRes.request;
                let response = operationRes.response;
                // Deserialize Response
                let parsedResponse = operationRes.bodyAsJson;
                try {
                    if (parsedResponse !== null && parsedResponse !== undefined) {
                        let resultMapper = Mappers.BatchAccount;
                        operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                    }
                }
                catch (error) {
                    let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                    deserializationError.request = msRest.stripRequest(httpRequest);
                    deserializationError.response = msRest.stripResponse(response);
                    return Promise.reject(deserializationError);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * Updates the properties of an existing Batch account.
     *
     * @param {string} resourceGroupName The name of the resource group that
     * contains the Batch account.
     *
     * @param {string} accountName The name of the Batch account.
     *
     * @param {BatchAccountUpdateParameters} parameters Additional parameters for
     * account update.
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    updateWithHttpOperationResponse(resourceGroupName, accountName, parameters, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            // Validate
            try {
                if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
                    throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
                }
                if (resourceGroupName !== null && resourceGroupName !== undefined) {
                    if (resourceGroupName.match(/^[-\w\._]+$/) === null) {
                        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._]+$/');
                    }
                }
                if (accountName === null || accountName === undefined || typeof accountName.valueOf() !== 'string') {
                    throw new Error('accountName cannot be null or undefined and it must be of type string.');
                }
                if (accountName !== null && accountName !== undefined) {
                    if (accountName.length > 24) {
                        throw new Error('"accountName" should satisfy the constraint - "MaxLength": 24');
                    }
                    if (accountName.length < 3) {
                        throw new Error('"accountName" should satisfy the constraint - "MinLength": 3');
                    }
                    if (accountName.match(/^[-\w\._]+$/) === null) {
                        throw new Error('"accountName" should satisfy the constraint - "Pattern": /^[-\w\._]+$/');
                    }
                }
                if (parameters === null || parameters === undefined) {
                    throw new Error('parameters cannot be null or undefined.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
                    throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Batch/batchAccounts/{accountName}';
            requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
            requestUrl = requestUrl.replace('{accountName}', encodeURIComponent(accountName));
            requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'PATCH';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['x-ms-client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            // Serialize Request
            let requestContent = null;
            let requestModel = null;
            try {
                if (parameters !== null && parameters !== undefined) {
                    let requestModelMapper = Mappers.BatchAccountUpdateParameters;
                    requestModel = client.serializer.serialize(requestModelMapper, parameters, 'parameters');
                    requestContent = JSON.stringify(requestModel);
                }
            }
            catch (error) {
                let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
                    `payload - ${JSON.stringify(parameters, null, 2)}.`);
                return Promise.reject(serializationError);
            }
            httpRequest.body = requestContent;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            if (parsedErrorResponse.error)
                                parsedErrorResponse = parsedErrorResponse.error;
                            if (parsedErrorResponse.code)
                                error.code = parsedErrorResponse.code;
                            if (parsedErrorResponse.message)
                                error.message = parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.CloudError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = Mappers.BatchAccount;
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * Deletes the specified Batch account.
     *
     * @param {string} resourceGroupName The name of the resource group that
     * contains the Batch account.
     *
     * @param {string} accountName The name of the Batch account.
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    deleteMethodWithHttpOperationResponse(resourceGroupName, accountName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            // Send request
            let initialResult;
            try {
                initialResult = yield this.beginDeleteMethodWithHttpOperationResponse(resourceGroupName, accountName, options);
            }
            catch (err) {
                return Promise.reject(err);
            }
            let operationRes;
            try {
                operationRes = yield client.getLongRunningOperationResult(initialResult, options);
                // Deserialize Response
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * Gets information about the specified Batch account.
     *
     * @param {string} resourceGroupName The name of the resource group that
     * contains the Batch account.
     *
     * @param {string} accountName The name of the Batch account.
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getWithHttpOperationResponse(resourceGroupName, accountName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            // Validate
            try {
                if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
                    throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
                }
                if (resourceGroupName !== null && resourceGroupName !== undefined) {
                    if (resourceGroupName.match(/^[-\w\._]+$/) === null) {
                        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._]+$/');
                    }
                }
                if (accountName === null || accountName === undefined || typeof accountName.valueOf() !== 'string') {
                    throw new Error('accountName cannot be null or undefined and it must be of type string.');
                }
                if (accountName !== null && accountName !== undefined) {
                    if (accountName.length > 24) {
                        throw new Error('"accountName" should satisfy the constraint - "MaxLength": 24');
                    }
                    if (accountName.length < 3) {
                        throw new Error('"accountName" should satisfy the constraint - "MinLength": 3');
                    }
                    if (accountName.match(/^[-\w\._]+$/) === null) {
                        throw new Error('"accountName" should satisfy the constraint - "Pattern": /^[-\w\._]+$/');
                    }
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
                    throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Batch/batchAccounts/{accountName}';
            requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
            requestUrl = requestUrl.replace('{accountName}', encodeURIComponent(accountName));
            requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['x-ms-client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            if (parsedErrorResponse.error)
                                parsedErrorResponse = parsedErrorResponse.error;
                            if (parsedErrorResponse.code)
                                error.code = parsedErrorResponse.code;
                            if (parsedErrorResponse.message)
                                error.message = parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.CloudError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = Mappers.BatchAccount;
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * Gets information about the Batch accounts associated with the subscription.
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listWithHttpOperationResponse(options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            // Validate
            try {
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
                    throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/providers/Microsoft.Batch/batchAccounts';
            requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['x-ms-client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            if (parsedErrorResponse.error)
                                parsedErrorResponse = parsedErrorResponse.error;
                            if (parsedErrorResponse.code)
                                error.code = parsedErrorResponse.code;
                            if (parsedErrorResponse.message)
                                error.message = parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.CloudError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = Mappers.BatchAccountListResult;
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * Gets information about the Batch accounts associated with the specified
     * resource group.
     *
     * @param {string} resourceGroupName The name of the resource group that
     * contains the Batch account.
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listByResourceGroupWithHttpOperationResponse(resourceGroupName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            // Validate
            try {
                if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
                    throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
                }
                if (resourceGroupName !== null && resourceGroupName !== undefined) {
                    if (resourceGroupName.match(/^[-\w\._]+$/) === null) {
                        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._]+$/');
                    }
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
                    throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Batch/batchAccounts';
            requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
            requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['x-ms-client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            if (parsedErrorResponse.error)
                                parsedErrorResponse = parsedErrorResponse.error;
                            if (parsedErrorResponse.code)
                                error.code = parsedErrorResponse.code;
                            if (parsedErrorResponse.message)
                                error.message = parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.CloudError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = Mappers.BatchAccountListResult;
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * Synchronizes access keys for the auto-storage account configured for the
     * specified Batch account.
     *
     * @param {string} resourceGroupName The name of the resource group that
     * contains the Batch account.
     *
     * @param {string} accountName The name of the Batch account.
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    synchronizeAutoStorageKeysWithHttpOperationResponse(resourceGroupName, accountName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            // Validate
            try {
                if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
                    throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
                }
                if (resourceGroupName !== null && resourceGroupName !== undefined) {
                    if (resourceGroupName.match(/^[-\w\._]+$/) === null) {
                        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._]+$/');
                    }
                }
                if (accountName === null || accountName === undefined || typeof accountName.valueOf() !== 'string') {
                    throw new Error('accountName cannot be null or undefined and it must be of type string.');
                }
                if (accountName !== null && accountName !== undefined) {
                    if (accountName.length > 24) {
                        throw new Error('"accountName" should satisfy the constraint - "MaxLength": 24');
                    }
                    if (accountName.length < 3) {
                        throw new Error('"accountName" should satisfy the constraint - "MinLength": 3');
                    }
                    if (accountName.match(/^[-\w\._]+$/) === null) {
                        throw new Error('"accountName" should satisfy the constraint - "Pattern": /^[-\w\._]+$/');
                    }
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
                    throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Batch/batchAccounts/{accountName}/syncAutoStorageKeys';
            requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
            requestUrl = requestUrl.replace('{accountName}', encodeURIComponent(accountName));
            requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'POST';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['x-ms-client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 204) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            if (parsedErrorResponse.error)
                                parsedErrorResponse = parsedErrorResponse.error;
                            if (parsedErrorResponse.code)
                                error.code = parsedErrorResponse.code;
                            if (parsedErrorResponse.message)
                                error.message = parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.CloudError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * Regenerates the specified account key for the Batch account.
     *
     * @param {string} resourceGroupName The name of the resource group that
     * contains the Batch account.
     *
     * @param {string} accountName The name of the Batch account.
     *
     * @param {AccountKeyType} keyName The type of account key to regenerate.
     * Possible values include: 'Primary', 'Secondary'
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    regenerateKeyWithHttpOperationResponse(resourceGroupName, accountName, keyName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            // Validate
            try {
                if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
                    throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
                }
                if (resourceGroupName !== null && resourceGroupName !== undefined) {
                    if (resourceGroupName.match(/^[-\w\._]+$/) === null) {
                        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._]+$/');
                    }
                }
                if (accountName === null || accountName === undefined || typeof accountName.valueOf() !== 'string') {
                    throw new Error('accountName cannot be null or undefined and it must be of type string.');
                }
                if (accountName !== null && accountName !== undefined) {
                    if (accountName.length > 24) {
                        throw new Error('"accountName" should satisfy the constraint - "MaxLength": 24');
                    }
                    if (accountName.length < 3) {
                        throw new Error('"accountName" should satisfy the constraint - "MinLength": 3');
                    }
                    if (accountName.match(/^[-\w\._]+$/) === null) {
                        throw new Error('"accountName" should satisfy the constraint - "Pattern": /^[-\w\._]+$/');
                    }
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
                    throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
                }
                if (keyName) {
                    let allowedValues = ['Primary', 'Secondary'];
                    if (!allowedValues.some(function (item) { return item === keyName; })) {
                        throw new Error(keyName + ' is not a valid value. The valid values are: ' + allowedValues);
                    }
                }
                else {
                    throw new Error('keyName cannot be null or undefined.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let parameters;
            if (keyName !== null && keyName !== undefined) {
                parameters = {};
                parameters.keyName = keyName;
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Batch/batchAccounts/{accountName}/regenerateKeys';
            requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
            requestUrl = requestUrl.replace('{accountName}', encodeURIComponent(accountName));
            requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'POST';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['x-ms-client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            // Serialize Request
            let requestContent = null;
            let requestModel = null;
            try {
                if (parameters !== null && parameters !== undefined) {
                    let requestModelMapper = Mappers.BatchAccountRegenerateKeyParameters;
                    requestModel = client.serializer.serialize(requestModelMapper, parameters, 'parameters');
                    requestContent = JSON.stringify(requestModel);
                }
            }
            catch (error) {
                let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
                    `payload - ${JSON.stringify(parameters, null, 2)}.`);
                return Promise.reject(serializationError);
            }
            httpRequest.body = requestContent;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            if (parsedErrorResponse.error)
                                parsedErrorResponse = parsedErrorResponse.error;
                            if (parsedErrorResponse.code)
                                error.code = parsedErrorResponse.code;
                            if (parsedErrorResponse.message)
                                error.message = parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.CloudError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = Mappers.BatchAccountKeys;
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * @summary Gets the account keys for the specified Batch account.
     *
     * This operation applies only to Batch accounts created with a
     * poolAllocationMode of 'BatchService'. If the Batch account was created with
     * a poolAllocationMode of 'UserSubscription', clients cannot use access to
     * keys to authenticate, and must use Azure Active Directory instead. In this
     * case, getting the keys will fail.
     *
     * @param {string} resourceGroupName The name of the resource group that
     * contains the Batch account.
     *
     * @param {string} accountName The name of the Batch account.
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getKeysWithHttpOperationResponse(resourceGroupName, accountName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            // Validate
            try {
                if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
                    throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
                }
                if (resourceGroupName !== null && resourceGroupName !== undefined) {
                    if (resourceGroupName.match(/^[-\w\._]+$/) === null) {
                        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._]+$/');
                    }
                }
                if (accountName === null || accountName === undefined || typeof accountName.valueOf() !== 'string') {
                    throw new Error('accountName cannot be null or undefined and it must be of type string.');
                }
                if (accountName !== null && accountName !== undefined) {
                    if (accountName.length > 24) {
                        throw new Error('"accountName" should satisfy the constraint - "MaxLength": 24');
                    }
                    if (accountName.length < 3) {
                        throw new Error('"accountName" should satisfy the constraint - "MinLength": 3');
                    }
                    if (accountName.match(/^[-\w\._]+$/) === null) {
                        throw new Error('"accountName" should satisfy the constraint - "Pattern": /^[-\w\._]+$/');
                    }
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
                    throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Batch/batchAccounts/{accountName}/listKeys';
            requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
            requestUrl = requestUrl.replace('{accountName}', encodeURIComponent(accountName));
            requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'POST';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['x-ms-client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            if (parsedErrorResponse.error)
                                parsedErrorResponse = parsedErrorResponse.error;
                            if (parsedErrorResponse.code)
                                error.code = parsedErrorResponse.code;
                            if (parsedErrorResponse.message)
                                error.message = parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.CloudError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = Mappers.BatchAccountKeys;
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * Creates a new Batch account with the specified parameters. Existing accounts
     * cannot be updated with this API and should instead be updated with the
     * Update Batch Account API.
     *
     * @param {string} resourceGroupName The name of the resource group that
     * contains the Batch account.
     *
     * @param {string} accountName A name for the Batch account which must be
     * unique within the region. Batch account names must be between 3 and 24
     * characters in length and must use only numbers and lowercase letters. This
     * name is used as part of the DNS name that is used to access the Batch
     * service in the region in which the account is created. For example:
     * http://accountname.region.batch.azure.com/.
     *
     * @param {BatchAccountCreateParameters} parameters Additional parameters for
     * account creation.
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    beginCreateWithHttpOperationResponse(resourceGroupName, accountName, parameters, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            // Validate
            try {
                if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
                    throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
                }
                if (resourceGroupName !== null && resourceGroupName !== undefined) {
                    if (resourceGroupName.match(/^[-\w\._]+$/) === null) {
                        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._]+$/');
                    }
                }
                if (accountName === null || accountName === undefined || typeof accountName.valueOf() !== 'string') {
                    throw new Error('accountName cannot be null or undefined and it must be of type string.');
                }
                if (accountName !== null && accountName !== undefined) {
                    if (accountName.length > 24) {
                        throw new Error('"accountName" should satisfy the constraint - "MaxLength": 24');
                    }
                    if (accountName.length < 3) {
                        throw new Error('"accountName" should satisfy the constraint - "MinLength": 3');
                    }
                    if (accountName.match(/^[-\w\._]+$/) === null) {
                        throw new Error('"accountName" should satisfy the constraint - "Pattern": /^[-\w\._]+$/');
                    }
                }
                if (parameters === null || parameters === undefined) {
                    throw new Error('parameters cannot be null or undefined.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
                    throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Batch/batchAccounts/{accountName}';
            requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
            requestUrl = requestUrl.replace('{accountName}', encodeURIComponent(accountName));
            requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'PUT';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['x-ms-client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            // Serialize Request
            let requestContent = null;
            let requestModel = null;
            try {
                if (parameters !== null && parameters !== undefined) {
                    let requestModelMapper = Mappers.BatchAccountCreateParameters;
                    requestModel = client.serializer.serialize(requestModelMapper, parameters, 'parameters');
                    requestContent = JSON.stringify(requestModel);
                }
            }
            catch (error) {
                let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
                    `payload - ${JSON.stringify(parameters, null, 2)}.`);
                return Promise.reject(serializationError);
            }
            httpRequest.body = requestContent;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200 && statusCode !== 202) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            if (parsedErrorResponse.error)
                                parsedErrorResponse = parsedErrorResponse.error;
                            if (parsedErrorResponse.code)
                                error.code = parsedErrorResponse.code;
                            if (parsedErrorResponse.message)
                                error.message = parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.CloudError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = Mappers.BatchAccount;
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * Deletes the specified Batch account.
     *
     * @param {string} resourceGroupName The name of the resource group that
     * contains the Batch account.
     *
     * @param {string} accountName The name of the Batch account.
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    beginDeleteMethodWithHttpOperationResponse(resourceGroupName, accountName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            // Validate
            try {
                if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
                    throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
                }
                if (resourceGroupName !== null && resourceGroupName !== undefined) {
                    if (resourceGroupName.match(/^[-\w\._]+$/) === null) {
                        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._]+$/');
                    }
                }
                if (accountName === null || accountName === undefined || typeof accountName.valueOf() !== 'string') {
                    throw new Error('accountName cannot be null or undefined and it must be of type string.');
                }
                if (accountName !== null && accountName !== undefined) {
                    if (accountName.length > 24) {
                        throw new Error('"accountName" should satisfy the constraint - "MaxLength": 24');
                    }
                    if (accountName.length < 3) {
                        throw new Error('"accountName" should satisfy the constraint - "MinLength": 3');
                    }
                    if (accountName.match(/^[-\w\._]+$/) === null) {
                        throw new Error('"accountName" should satisfy the constraint - "Pattern": /^[-\w\._]+$/');
                    }
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
                    throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Batch/batchAccounts/{accountName}';
            requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
            requestUrl = requestUrl.replace('{accountName}', encodeURIComponent(accountName));
            requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'DELETE';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['x-ms-client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200 && statusCode !== 202 && statusCode !== 204) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            if (parsedErrorResponse.error)
                                parsedErrorResponse = parsedErrorResponse.error;
                            if (parsedErrorResponse.code)
                                error.code = parsedErrorResponse.code;
                            if (parsedErrorResponse.message)
                                error.message = parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.CloudError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * Gets information about the Batch accounts associated with the subscription.
     *
     * @param {string} nextPageLink The NextLink from the previous successful call
     * to List operation.
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listNextWithHttpOperationResponse(nextPageLink, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            // Validate
            try {
                if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
                    throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let requestUrl = '{nextLink}';
            requestUrl = requestUrl.replace('{nextLink}', nextPageLink);
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['x-ms-client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            if (parsedErrorResponse.error)
                                parsedErrorResponse = parsedErrorResponse.error;
                            if (parsedErrorResponse.code)
                                error.code = parsedErrorResponse.code;
                            if (parsedErrorResponse.message)
                                error.message = parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.CloudError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = Mappers.BatchAccountListResult;
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * Gets information about the Batch accounts associated with the specified
     * resource group.
     *
     * @param {string} nextPageLink The NextLink from the previous successful call
     * to List operation.
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listByResourceGroupNextWithHttpOperationResponse(nextPageLink, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            // Validate
            try {
                if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
                    throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let requestUrl = '{nextLink}';
            requestUrl = requestUrl.replace('{nextLink}', nextPageLink);
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['x-ms-client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            if (parsedErrorResponse.error)
                                parsedErrorResponse = parsedErrorResponse.error;
                            if (parsedErrorResponse.code)
                                error.code = parsedErrorResponse.code;
                            if (parsedErrorResponse.message)
                                error.message = parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.CloudError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = Mappers.BatchAccountListResult;
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    create(resourceGroupName, accountName, parameters, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.createWithHttpOperationResponse(resourceGroupName, accountName, parameters, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.createWithHttpOperationResponse(resourceGroupName, accountName, parameters, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    update(resourceGroupName, accountName, parameters, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.updateWithHttpOperationResponse(resourceGroupName, accountName, parameters, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.updateWithHttpOperationResponse(resourceGroupName, accountName, parameters, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    deleteMethod(resourceGroupName, accountName, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.deleteMethodWithHttpOperationResponse(resourceGroupName, accountName, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.deleteMethodWithHttpOperationResponse(resourceGroupName, accountName, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    get(resourceGroupName, accountName, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getWithHttpOperationResponse(resourceGroupName, accountName, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getWithHttpOperationResponse(resourceGroupName, accountName, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    list(options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listWithHttpOperationResponse(options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listWithHttpOperationResponse(options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    listByResourceGroup(resourceGroupName, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listByResourceGroupWithHttpOperationResponse(resourceGroupName, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listByResourceGroupWithHttpOperationResponse(resourceGroupName, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    synchronizeAutoStorageKeys(resourceGroupName, accountName, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.synchronizeAutoStorageKeysWithHttpOperationResponse(resourceGroupName, accountName, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.synchronizeAutoStorageKeysWithHttpOperationResponse(resourceGroupName, accountName, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    regenerateKey(resourceGroupName, accountName, keyName, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.regenerateKeyWithHttpOperationResponse(resourceGroupName, accountName, keyName, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.regenerateKeyWithHttpOperationResponse(resourceGroupName, accountName, keyName, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    getKeys(resourceGroupName, accountName, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getKeysWithHttpOperationResponse(resourceGroupName, accountName, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getKeysWithHttpOperationResponse(resourceGroupName, accountName, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    beginCreate(resourceGroupName, accountName, parameters, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.beginCreateWithHttpOperationResponse(resourceGroupName, accountName, parameters, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.beginCreateWithHttpOperationResponse(resourceGroupName, accountName, parameters, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    beginDeleteMethod(resourceGroupName, accountName, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.beginDeleteMethodWithHttpOperationResponse(resourceGroupName, accountName, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.beginDeleteMethodWithHttpOperationResponse(resourceGroupName, accountName, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    listNext(nextPageLink, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listNextWithHttpOperationResponse(nextPageLink, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listNextWithHttpOperationResponse(nextPageLink, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    listByResourceGroupNext(nextPageLink, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listByResourceGroupNextWithHttpOperationResponse(nextPageLink, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listByResourceGroupNextWithHttpOperationResponse(nextPageLink, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
}
exports.BatchAccountOperations = BatchAccountOperations;


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const msRest = __webpack_require__(1);
const Mappers = __webpack_require__(0);
const WebResource = msRest.WebResource;
/** Class representing a ApplicationPackageOperations. */
class ApplicationPackageOperations {
    /**
     * Create a ApplicationPackageOperations.
     * @param {BatchManagementClient} client Reference to the service client.
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Activates the specified application package.
     *
     * @param {string} resourceGroupName The name of the resource group that
     * contains the Batch account.
     *
     * @param {string} accountName The name of the Batch account.
     *
     * @param {string} applicationId The ID of the application.
     *
     * @param {string} version The version of the application to activate.
     *
     * @param {string} format The format of the application package binary file.
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    activateWithHttpOperationResponse(resourceGroupName, accountName, applicationId, version, format, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            // Validate
            try {
                if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
                    throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
                }
                if (resourceGroupName !== null && resourceGroupName !== undefined) {
                    if (resourceGroupName.match(/^[-\w\._]+$/) === null) {
                        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._]+$/');
                    }
                }
                if (accountName === null || accountName === undefined || typeof accountName.valueOf() !== 'string') {
                    throw new Error('accountName cannot be null or undefined and it must be of type string.');
                }
                if (accountName !== null && accountName !== undefined) {
                    if (accountName.length > 24) {
                        throw new Error('"accountName" should satisfy the constraint - "MaxLength": 24');
                    }
                    if (accountName.length < 3) {
                        throw new Error('"accountName" should satisfy the constraint - "MinLength": 3');
                    }
                    if (accountName.match(/^[-\w\._]+$/) === null) {
                        throw new Error('"accountName" should satisfy the constraint - "Pattern": /^[-\w\._]+$/');
                    }
                }
                if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
                    throw new Error('applicationId cannot be null or undefined and it must be of type string.');
                }
                if (version === null || version === undefined || typeof version.valueOf() !== 'string') {
                    throw new Error('version cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
                    throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
                }
                if (format === null || format === undefined || typeof format.valueOf() !== 'string') {
                    throw new Error('format cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let parameters;
            if (format !== null && format !== undefined) {
                parameters = {};
                parameters.format = format;
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Batch/batchAccounts/{accountName}/applications/{applicationId}/versions/{version}/activate';
            requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
            requestUrl = requestUrl.replace('{accountName}', encodeURIComponent(accountName));
            requestUrl = requestUrl.replace('{applicationId}', encodeURIComponent(applicationId));
            requestUrl = requestUrl.replace('{version}', encodeURIComponent(version));
            requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'POST';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['x-ms-client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            // Serialize Request
            let requestContent = null;
            let requestModel = null;
            try {
                if (parameters !== null && parameters !== undefined) {
                    let requestModelMapper = Mappers.ActivateApplicationPackageParameters;
                    requestModel = client.serializer.serialize(requestModelMapper, parameters, 'parameters');
                    requestContent = JSON.stringify(requestModel);
                }
            }
            catch (error) {
                let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
                    `payload - ${JSON.stringify(parameters, null, 2)}.`);
                return Promise.reject(serializationError);
            }
            httpRequest.body = requestContent;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 204) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            if (parsedErrorResponse.error)
                                parsedErrorResponse = parsedErrorResponse.error;
                            if (parsedErrorResponse.code)
                                error.code = parsedErrorResponse.code;
                            if (parsedErrorResponse.message)
                                error.message = parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.CloudError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * Creates an application package record.
     *
     * @param {string} resourceGroupName The name of the resource group that
     * contains the Batch account.
     *
     * @param {string} accountName The name of the Batch account.
     *
     * @param {string} applicationId The ID of the application.
     *
     * @param {string} version The version of the application.
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    createWithHttpOperationResponse(resourceGroupName, accountName, applicationId, version, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            // Validate
            try {
                if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
                    throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
                }
                if (resourceGroupName !== null && resourceGroupName !== undefined) {
                    if (resourceGroupName.match(/^[-\w\._]+$/) === null) {
                        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._]+$/');
                    }
                }
                if (accountName === null || accountName === undefined || typeof accountName.valueOf() !== 'string') {
                    throw new Error('accountName cannot be null or undefined and it must be of type string.');
                }
                if (accountName !== null && accountName !== undefined) {
                    if (accountName.length > 24) {
                        throw new Error('"accountName" should satisfy the constraint - "MaxLength": 24');
                    }
                    if (accountName.length < 3) {
                        throw new Error('"accountName" should satisfy the constraint - "MinLength": 3');
                    }
                    if (accountName.match(/^[-\w\._]+$/) === null) {
                        throw new Error('"accountName" should satisfy the constraint - "Pattern": /^[-\w\._]+$/');
                    }
                }
                if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
                    throw new Error('applicationId cannot be null or undefined and it must be of type string.');
                }
                if (version === null || version === undefined || typeof version.valueOf() !== 'string') {
                    throw new Error('version cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
                    throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Batch/batchAccounts/{accountName}/applications/{applicationId}/versions/{version}';
            requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
            requestUrl = requestUrl.replace('{accountName}', encodeURIComponent(accountName));
            requestUrl = requestUrl.replace('{applicationId}', encodeURIComponent(applicationId));
            requestUrl = requestUrl.replace('{version}', encodeURIComponent(version));
            requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'PUT';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['x-ms-client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 201) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            if (parsedErrorResponse.error)
                                parsedErrorResponse = parsedErrorResponse.error;
                            if (parsedErrorResponse.code)
                                error.code = parsedErrorResponse.code;
                            if (parsedErrorResponse.message)
                                error.message = parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.CloudError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 201) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = Mappers.ApplicationPackage;
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * Deletes an application package record and its associated binary file.
     *
     * @param {string} resourceGroupName The name of the resource group that
     * contains the Batch account.
     *
     * @param {string} accountName The name of the Batch account.
     *
     * @param {string} applicationId The ID of the application.
     *
     * @param {string} version The version of the application to delete.
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    deleteMethodWithHttpOperationResponse(resourceGroupName, accountName, applicationId, version, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            // Validate
            try {
                if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
                    throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
                }
                if (resourceGroupName !== null && resourceGroupName !== undefined) {
                    if (resourceGroupName.match(/^[-\w\._]+$/) === null) {
                        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._]+$/');
                    }
                }
                if (accountName === null || accountName === undefined || typeof accountName.valueOf() !== 'string') {
                    throw new Error('accountName cannot be null or undefined and it must be of type string.');
                }
                if (accountName !== null && accountName !== undefined) {
                    if (accountName.length > 24) {
                        throw new Error('"accountName" should satisfy the constraint - "MaxLength": 24');
                    }
                    if (accountName.length < 3) {
                        throw new Error('"accountName" should satisfy the constraint - "MinLength": 3');
                    }
                    if (accountName.match(/^[-\w\._]+$/) === null) {
                        throw new Error('"accountName" should satisfy the constraint - "Pattern": /^[-\w\._]+$/');
                    }
                }
                if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
                    throw new Error('applicationId cannot be null or undefined and it must be of type string.');
                }
                if (version === null || version === undefined || typeof version.valueOf() !== 'string') {
                    throw new Error('version cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
                    throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Batch/batchAccounts/{accountName}/applications/{applicationId}/versions/{version}';
            requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
            requestUrl = requestUrl.replace('{accountName}', encodeURIComponent(accountName));
            requestUrl = requestUrl.replace('{applicationId}', encodeURIComponent(applicationId));
            requestUrl = requestUrl.replace('{version}', encodeURIComponent(version));
            requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'DELETE';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['x-ms-client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 204) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            if (parsedErrorResponse.error)
                                parsedErrorResponse = parsedErrorResponse.error;
                            if (parsedErrorResponse.code)
                                error.code = parsedErrorResponse.code;
                            if (parsedErrorResponse.message)
                                error.message = parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.CloudError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * Gets information about the specified application package.
     *
     * @param {string} resourceGroupName The name of the resource group that
     * contains the Batch account.
     *
     * @param {string} accountName The name of the Batch account.
     *
     * @param {string} applicationId The ID of the application.
     *
     * @param {string} version The version of the application.
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getWithHttpOperationResponse(resourceGroupName, accountName, applicationId, version, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            // Validate
            try {
                if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
                    throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
                }
                if (resourceGroupName !== null && resourceGroupName !== undefined) {
                    if (resourceGroupName.match(/^[-\w\._]+$/) === null) {
                        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._]+$/');
                    }
                }
                if (accountName === null || accountName === undefined || typeof accountName.valueOf() !== 'string') {
                    throw new Error('accountName cannot be null or undefined and it must be of type string.');
                }
                if (accountName !== null && accountName !== undefined) {
                    if (accountName.length > 24) {
                        throw new Error('"accountName" should satisfy the constraint - "MaxLength": 24');
                    }
                    if (accountName.length < 3) {
                        throw new Error('"accountName" should satisfy the constraint - "MinLength": 3');
                    }
                    if (accountName.match(/^[-\w\._]+$/) === null) {
                        throw new Error('"accountName" should satisfy the constraint - "Pattern": /^[-\w\._]+$/');
                    }
                }
                if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
                    throw new Error('applicationId cannot be null or undefined and it must be of type string.');
                }
                if (version === null || version === undefined || typeof version.valueOf() !== 'string') {
                    throw new Error('version cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
                    throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Batch/batchAccounts/{accountName}/applications/{applicationId}/versions/{version}';
            requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
            requestUrl = requestUrl.replace('{accountName}', encodeURIComponent(accountName));
            requestUrl = requestUrl.replace('{applicationId}', encodeURIComponent(applicationId));
            requestUrl = requestUrl.replace('{version}', encodeURIComponent(version));
            requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['x-ms-client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            if (parsedErrorResponse.error)
                                parsedErrorResponse = parsedErrorResponse.error;
                            if (parsedErrorResponse.code)
                                error.code = parsedErrorResponse.code;
                            if (parsedErrorResponse.message)
                                error.message = parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.CloudError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = Mappers.ApplicationPackage;
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    activate(resourceGroupName, accountName, applicationId, version, format, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.activateWithHttpOperationResponse(resourceGroupName, accountName, applicationId, version, format, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.activateWithHttpOperationResponse(resourceGroupName, accountName, applicationId, version, format, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    create(resourceGroupName, accountName, applicationId, version, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.createWithHttpOperationResponse(resourceGroupName, accountName, applicationId, version, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.createWithHttpOperationResponse(resourceGroupName, accountName, applicationId, version, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    deleteMethod(resourceGroupName, accountName, applicationId, version, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.deleteMethodWithHttpOperationResponse(resourceGroupName, accountName, applicationId, version, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.deleteMethodWithHttpOperationResponse(resourceGroupName, accountName, applicationId, version, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    get(resourceGroupName, accountName, applicationId, version, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getWithHttpOperationResponse(resourceGroupName, accountName, applicationId, version, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getWithHttpOperationResponse(resourceGroupName, accountName, applicationId, version, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
}
exports.ApplicationPackageOperations = ApplicationPackageOperations;


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const msRest = __webpack_require__(1);
const Mappers = __webpack_require__(0);
const WebResource = msRest.WebResource;
/** Class representing a ApplicationOperations. */
class ApplicationOperations {
    /**
     * Create a ApplicationOperations.
     * @param {BatchManagementClient} client Reference to the service client.
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Adds an application to the specified Batch account.
     *
     * @param {string} resourceGroupName The name of the resource group that
     * contains the Batch account.
     *
     * @param {string} accountName The name of the Batch account.
     *
     * @param {string} applicationId The ID of the application.
     *
     * @param {ApplicationCreateOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    createWithHttpOperationResponse(resourceGroupName, accountName, applicationId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let parameters = (options && options.parameters !== undefined) ? options.parameters : undefined;
            // Validate
            try {
                if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
                    throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
                }
                if (resourceGroupName !== null && resourceGroupName !== undefined) {
                    if (resourceGroupName.match(/^[-\w\._]+$/) === null) {
                        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._]+$/');
                    }
                }
                if (accountName === null || accountName === undefined || typeof accountName.valueOf() !== 'string') {
                    throw new Error('accountName cannot be null or undefined and it must be of type string.');
                }
                if (accountName !== null && accountName !== undefined) {
                    if (accountName.length > 24) {
                        throw new Error('"accountName" should satisfy the constraint - "MaxLength": 24');
                    }
                    if (accountName.length < 3) {
                        throw new Error('"accountName" should satisfy the constraint - "MinLength": 3');
                    }
                    if (accountName.match(/^[-\w\._]+$/) === null) {
                        throw new Error('"accountName" should satisfy the constraint - "Pattern": /^[-\w\._]+$/');
                    }
                }
                if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
                    throw new Error('applicationId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
                    throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Batch/batchAccounts/{accountName}/applications/{applicationId}';
            requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
            requestUrl = requestUrl.replace('{accountName}', encodeURIComponent(accountName));
            requestUrl = requestUrl.replace('{applicationId}', encodeURIComponent(applicationId));
            requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'PUT';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['x-ms-client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            // Serialize Request
            let requestContent = null;
            let requestModel = null;
            try {
                if (parameters !== null && parameters !== undefined) {
                    let requestModelMapper = Mappers.ApplicationCreateParameters;
                    requestModel = client.serializer.serialize(requestModelMapper, parameters, 'parameters');
                    requestContent = JSON.stringify(requestModel);
                }
            }
            catch (error) {
                let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
                    `payload - ${JSON.stringify(parameters, null, 2)}.`);
                return Promise.reject(serializationError);
            }
            httpRequest.body = requestContent;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 201) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            if (parsedErrorResponse.error)
                                parsedErrorResponse = parsedErrorResponse.error;
                            if (parsedErrorResponse.code)
                                error.code = parsedErrorResponse.code;
                            if (parsedErrorResponse.message)
                                error.message = parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.CloudError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 201) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = Mappers.Application;
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * Deletes an application.
     *
     * @param {string} resourceGroupName The name of the resource group that
     * contains the Batch account.
     *
     * @param {string} accountName The name of the Batch account.
     *
     * @param {string} applicationId The ID of the application.
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    deleteMethodWithHttpOperationResponse(resourceGroupName, accountName, applicationId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            // Validate
            try {
                if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
                    throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
                }
                if (resourceGroupName !== null && resourceGroupName !== undefined) {
                    if (resourceGroupName.match(/^[-\w\._]+$/) === null) {
                        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._]+$/');
                    }
                }
                if (accountName === null || accountName === undefined || typeof accountName.valueOf() !== 'string') {
                    throw new Error('accountName cannot be null or undefined and it must be of type string.');
                }
                if (accountName !== null && accountName !== undefined) {
                    if (accountName.length > 24) {
                        throw new Error('"accountName" should satisfy the constraint - "MaxLength": 24');
                    }
                    if (accountName.length < 3) {
                        throw new Error('"accountName" should satisfy the constraint - "MinLength": 3');
                    }
                    if (accountName.match(/^[-\w\._]+$/) === null) {
                        throw new Error('"accountName" should satisfy the constraint - "Pattern": /^[-\w\._]+$/');
                    }
                }
                if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
                    throw new Error('applicationId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
                    throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Batch/batchAccounts/{accountName}/applications/{applicationId}';
            requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
            requestUrl = requestUrl.replace('{accountName}', encodeURIComponent(accountName));
            requestUrl = requestUrl.replace('{applicationId}', encodeURIComponent(applicationId));
            requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'DELETE';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['x-ms-client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 204) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            if (parsedErrorResponse.error)
                                parsedErrorResponse = parsedErrorResponse.error;
                            if (parsedErrorResponse.code)
                                error.code = parsedErrorResponse.code;
                            if (parsedErrorResponse.message)
                                error.message = parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.CloudError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * Gets information about the specified application.
     *
     * @param {string} resourceGroupName The name of the resource group that
     * contains the Batch account.
     *
     * @param {string} accountName The name of the Batch account.
     *
     * @param {string} applicationId The ID of the application.
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getWithHttpOperationResponse(resourceGroupName, accountName, applicationId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            // Validate
            try {
                if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
                    throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
                }
                if (resourceGroupName !== null && resourceGroupName !== undefined) {
                    if (resourceGroupName.match(/^[-\w\._]+$/) === null) {
                        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._]+$/');
                    }
                }
                if (accountName === null || accountName === undefined || typeof accountName.valueOf() !== 'string') {
                    throw new Error('accountName cannot be null or undefined and it must be of type string.');
                }
                if (accountName !== null && accountName !== undefined) {
                    if (accountName.length > 24) {
                        throw new Error('"accountName" should satisfy the constraint - "MaxLength": 24');
                    }
                    if (accountName.length < 3) {
                        throw new Error('"accountName" should satisfy the constraint - "MinLength": 3');
                    }
                    if (accountName.match(/^[-\w\._]+$/) === null) {
                        throw new Error('"accountName" should satisfy the constraint - "Pattern": /^[-\w\._]+$/');
                    }
                }
                if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
                    throw new Error('applicationId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
                    throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Batch/batchAccounts/{accountName}/applications/{applicationId}';
            requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
            requestUrl = requestUrl.replace('{accountName}', encodeURIComponent(accountName));
            requestUrl = requestUrl.replace('{applicationId}', encodeURIComponent(applicationId));
            requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['x-ms-client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            if (parsedErrorResponse.error)
                                parsedErrorResponse = parsedErrorResponse.error;
                            if (parsedErrorResponse.code)
                                error.code = parsedErrorResponse.code;
                            if (parsedErrorResponse.message)
                                error.message = parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.CloudError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = Mappers.Application;
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * Updates settings for the specified application.
     *
     * @param {string} resourceGroupName The name of the resource group that
     * contains the Batch account.
     *
     * @param {string} accountName The name of the Batch account.
     *
     * @param {string} applicationId The ID of the application.
     *
     * @param {ApplicationUpdateParameters} parameters The parameters for the
     * request.
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    updateWithHttpOperationResponse(resourceGroupName, accountName, applicationId, parameters, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            // Validate
            try {
                if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
                    throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
                }
                if (resourceGroupName !== null && resourceGroupName !== undefined) {
                    if (resourceGroupName.match(/^[-\w\._]+$/) === null) {
                        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._]+$/');
                    }
                }
                if (accountName === null || accountName === undefined || typeof accountName.valueOf() !== 'string') {
                    throw new Error('accountName cannot be null or undefined and it must be of type string.');
                }
                if (accountName !== null && accountName !== undefined) {
                    if (accountName.length > 24) {
                        throw new Error('"accountName" should satisfy the constraint - "MaxLength": 24');
                    }
                    if (accountName.length < 3) {
                        throw new Error('"accountName" should satisfy the constraint - "MinLength": 3');
                    }
                    if (accountName.match(/^[-\w\._]+$/) === null) {
                        throw new Error('"accountName" should satisfy the constraint - "Pattern": /^[-\w\._]+$/');
                    }
                }
                if (applicationId === null || applicationId === undefined || typeof applicationId.valueOf() !== 'string') {
                    throw new Error('applicationId cannot be null or undefined and it must be of type string.');
                }
                if (parameters === null || parameters === undefined) {
                    throw new Error('parameters cannot be null or undefined.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
                    throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Batch/batchAccounts/{accountName}/applications/{applicationId}';
            requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
            requestUrl = requestUrl.replace('{accountName}', encodeURIComponent(accountName));
            requestUrl = requestUrl.replace('{applicationId}', encodeURIComponent(applicationId));
            requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'PATCH';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['x-ms-client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            // Serialize Request
            let requestContent = null;
            let requestModel = null;
            try {
                if (parameters !== null && parameters !== undefined) {
                    let requestModelMapper = Mappers.ApplicationUpdateParameters;
                    requestModel = client.serializer.serialize(requestModelMapper, parameters, 'parameters');
                    requestContent = JSON.stringify(requestModel);
                }
            }
            catch (error) {
                let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
                    `payload - ${JSON.stringify(parameters, null, 2)}.`);
                return Promise.reject(serializationError);
            }
            httpRequest.body = requestContent;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 204) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            if (parsedErrorResponse.error)
                                parsedErrorResponse = parsedErrorResponse.error;
                            if (parsedErrorResponse.code)
                                error.code = parsedErrorResponse.code;
                            if (parsedErrorResponse.message)
                                error.message = parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.CloudError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * Lists all of the applications in the specified account.
     *
     * @param {string} resourceGroupName The name of the resource group that
     * contains the Batch account.
     *
     * @param {string} accountName The name of the Batch account.
     *
     * @param {ApplicationListOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listWithHttpOperationResponse(resourceGroupName, accountName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            let maxresults = (options && options.maxresults !== undefined) ? options.maxresults : undefined;
            // Validate
            try {
                if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
                    throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
                }
                if (resourceGroupName !== null && resourceGroupName !== undefined) {
                    if (resourceGroupName.match(/^[-\w\._]+$/) === null) {
                        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._]+$/');
                    }
                }
                if (accountName === null || accountName === undefined || typeof accountName.valueOf() !== 'string') {
                    throw new Error('accountName cannot be null or undefined and it must be of type string.');
                }
                if (accountName !== null && accountName !== undefined) {
                    if (accountName.length > 24) {
                        throw new Error('"accountName" should satisfy the constraint - "MaxLength": 24');
                    }
                    if (accountName.length < 3) {
                        throw new Error('"accountName" should satisfy the constraint - "MinLength": 3');
                    }
                    if (accountName.match(/^[-\w\._]+$/) === null) {
                        throw new Error('"accountName" should satisfy the constraint - "Pattern": /^[-\w\._]+$/');
                    }
                }
                if (maxresults !== null && maxresults !== undefined && typeof maxresults !== 'number') {
                    throw new Error('maxresults must be of type number.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
                    throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Batch/batchAccounts/{accountName}/applications';
            requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
            requestUrl = requestUrl.replace('{accountName}', encodeURIComponent(accountName));
            requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
            let queryParamsArray = [];
            if (maxresults !== null && maxresults !== undefined) {
                queryParamsArray.push('maxresults=' + encodeURIComponent(maxresults.toString()));
            }
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['x-ms-client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            if (parsedErrorResponse.error)
                                parsedErrorResponse = parsedErrorResponse.error;
                            if (parsedErrorResponse.code)
                                error.code = parsedErrorResponse.code;
                            if (parsedErrorResponse.message)
                                error.message = parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.CloudError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = Mappers.ListApplicationsResult;
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * Lists all of the applications in the specified account.
     *
     * @param {string} nextPageLink The NextLink from the previous successful call
     * to List operation.
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listNextWithHttpOperationResponse(nextPageLink, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            // Validate
            try {
                if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
                    throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let requestUrl = '{nextLink}';
            requestUrl = requestUrl.replace('{nextLink}', nextPageLink);
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['x-ms-client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            if (parsedErrorResponse.error)
                                parsedErrorResponse = parsedErrorResponse.error;
                            if (parsedErrorResponse.code)
                                error.code = parsedErrorResponse.code;
                            if (parsedErrorResponse.message)
                                error.message = parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.CloudError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = Mappers.ListApplicationsResult;
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    create(resourceGroupName, accountName, applicationId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.createWithHttpOperationResponse(resourceGroupName, accountName, applicationId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.createWithHttpOperationResponse(resourceGroupName, accountName, applicationId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    deleteMethod(resourceGroupName, accountName, applicationId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.deleteMethodWithHttpOperationResponse(resourceGroupName, accountName, applicationId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.deleteMethodWithHttpOperationResponse(resourceGroupName, accountName, applicationId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    get(resourceGroupName, accountName, applicationId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getWithHttpOperationResponse(resourceGroupName, accountName, applicationId, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getWithHttpOperationResponse(resourceGroupName, accountName, applicationId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    update(resourceGroupName, accountName, applicationId, parameters, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.updateWithHttpOperationResponse(resourceGroupName, accountName, applicationId, parameters, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.updateWithHttpOperationResponse(resourceGroupName, accountName, applicationId, parameters, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    list(resourceGroupName, accountName, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listWithHttpOperationResponse(resourceGroupName, accountName, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listWithHttpOperationResponse(resourceGroupName, accountName, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    listNext(nextPageLink, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listNextWithHttpOperationResponse(nextPageLink, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listNextWithHttpOperationResponse(nextPageLink, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
}
exports.ApplicationOperations = ApplicationOperations;


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const msRest = __webpack_require__(1);
const Mappers = __webpack_require__(0);
const WebResource = msRest.WebResource;
/** Class representing a Location. */
class Location {
    /**
     * Create a Location.
     * @param {BatchManagementClient} client Reference to the service client.
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets the Batch service quotas for the specified subscription at the given
     * location.
     *
     * @param {string} locationName The region for which to retrieve Batch service
     * quotas.
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    getQuotasWithHttpOperationResponse(locationName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            // Validate
            try {
                if (locationName === null || locationName === undefined || typeof locationName.valueOf() !== 'string') {
                    throw new Error('locationName cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
                    throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/providers/Microsoft.Batch/locations/{locationName}/quotas';
            requestUrl = requestUrl.replace('{locationName}', encodeURIComponent(locationName));
            requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['x-ms-client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            if (parsedErrorResponse.error)
                                parsedErrorResponse = parsedErrorResponse.error;
                            if (parsedErrorResponse.code)
                                error.code = parsedErrorResponse.code;
                            if (parsedErrorResponse.message)
                                error.message = parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.CloudError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = Mappers.BatchLocationQuota;
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * Checks whether the Batch account name is available in the specified region.
     *
     * @param {string} locationName The desired region for the name check.
     *
     * @param {string} name The name to check for availability
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    checkNameAvailabilityWithHttpOperationResponse(locationName, name, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            // Validate
            try {
                if (locationName === null || locationName === undefined || typeof locationName.valueOf() !== 'string') {
                    throw new Error('locationName cannot be null or undefined and it must be of type string.');
                }
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
                    throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
                }
                if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
                    throw new Error('name cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            let parameters = {};
            try {
                if (name !== null && name !== undefined) {
                    parameters.name = name;
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/providers/Microsoft.Batch/locations/{locationName}/checkNameAvailability';
            requestUrl = requestUrl.replace('{locationName}', encodeURIComponent(locationName));
            requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'POST';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['x-ms-client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            // Serialize Request
            let requestContent = null;
            let requestModel = null;
            try {
                if (parameters !== null && parameters !== undefined) {
                    let requestModelMapper = Mappers.CheckNameAvailabilityParameters;
                    requestModel = client.serializer.serialize(requestModelMapper, parameters, 'parameters');
                    requestContent = JSON.stringify(requestModel);
                }
            }
            catch (error) {
                let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
                    `payload - ${JSON.stringify(parameters, null, 2)}.`);
                return Promise.reject(serializationError);
            }
            httpRequest.body = requestContent;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            if (parsedErrorResponse.error)
                                parsedErrorResponse = parsedErrorResponse.error;
                            if (parsedErrorResponse.code)
                                error.code = parsedErrorResponse.code;
                            if (parsedErrorResponse.message)
                                error.message = parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.CloudError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = Mappers.CheckNameAvailabilityResult;
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    getQuotas(locationName, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getQuotasWithHttpOperationResponse(locationName, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getQuotasWithHttpOperationResponse(locationName, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    checkNameAvailability(locationName, name, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.checkNameAvailabilityWithHttpOperationResponse(locationName, name, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.checkNameAvailabilityWithHttpOperationResponse(locationName, name, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
}
exports.Location = Location;


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const msRest = __webpack_require__(1);
const Mappers = __webpack_require__(0);
const WebResource = msRest.WebResource;
/** Class representing a Operations. */
class Operations {
    /**
     * Create a Operations.
     * @param {BatchManagementClient} client Reference to the service client.
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists available operations for the Microsoft.Batch provider
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listWithHttpOperationResponse(options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            // Validate
            try {
                if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
                    throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let baseUrl = this.client.baseUri;
            let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'providers/Microsoft.Batch/operations';
            let queryParamsArray = [];
            queryParamsArray.push('api-version=' + encodeURIComponent(this.client.apiVersion));
            if (queryParamsArray.length > 0) {
                requestUrl += '?' + queryParamsArray.join('&');
            }
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['x-ms-client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            if (parsedErrorResponse.error)
                                parsedErrorResponse = parsedErrorResponse.error;
                            if (parsedErrorResponse.code)
                                error.code = parsedErrorResponse.code;
                            if (parsedErrorResponse.message)
                                error.message = parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.CloudError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = Mappers.OperationListResult;
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    /**
     * Lists available operations for the Microsoft.Batch provider
     *
     * @param {string} nextPageLink The NextLink from the previous successful call
     * to List operation.
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} - The deserialized result object.
     *
     * @reject {Error|ServiceError} - The error object.
     */
    listNextWithHttpOperationResponse(nextPageLink, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let client = this.client;
            // Validate
            try {
                if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
                    throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
                }
                if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
                    throw new Error('this.client.acceptLanguage must be of type string.');
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            // Construct URL
            let requestUrl = '{nextLink}';
            requestUrl = requestUrl.replace('{nextLink}', nextPageLink);
            // Create HTTP transport objects
            let httpRequest = new WebResource();
            httpRequest.method = 'GET';
            httpRequest.url = requestUrl;
            httpRequest.headers = {};
            // Set Headers
            httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
            if (this.client.generateClientRequestId) {
                httpRequest.headers['x-ms-client-request-id'] = msRest.generateUuid();
            }
            if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
                httpRequest.headers['accept-language'] = this.client.acceptLanguage;
            }
            if (options && options.customHeaders) {
                for (let headerName in options.customHeaders) {
                    if (options.customHeaders.hasOwnProperty(headerName)) {
                        httpRequest.headers[headerName] = options.customHeaders[headerName];
                    }
                }
            }
            httpRequest.body = null;
            // Send Request
            let operationRes;
            try {
                operationRes = yield client.pipeline(httpRequest);
                let response = operationRes.response;
                let statusCode = response.status;
                if (statusCode !== 200) {
                    let error = new msRest.RestError(operationRes.bodyAsText);
                    error.statusCode = response.status;
                    error.request = msRest.stripRequest(httpRequest);
                    error.response = msRest.stripResponse(response);
                    let parsedErrorResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedErrorResponse) {
                            if (parsedErrorResponse.error)
                                parsedErrorResponse = parsedErrorResponse.error;
                            if (parsedErrorResponse.code)
                                error.code = parsedErrorResponse.code;
                            if (parsedErrorResponse.message)
                                error.message = parsedErrorResponse.message;
                        }
                        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
                            let resultMapper = Mappers.CloudError;
                            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
                        }
                    }
                    catch (defaultError) {
                        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                            `- "${operationRes.bodyAsText}" for the default response.`;
                        return Promise.reject(error);
                    }
                    return Promise.reject(error);
                }
                // Deserialize Response
                if (statusCode === 200) {
                    let parsedResponse = operationRes.bodyAsJson;
                    try {
                        if (parsedResponse !== null && parsedResponse !== undefined) {
                            let resultMapper = Mappers.OperationListResult;
                            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(response);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    list(options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listWithHttpOperationResponse(options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listWithHttpOperationResponse(options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
    listNext(nextPageLink, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.listNextWithHttpOperationResponse(nextPageLink, options).then((operationRes) => {
                return Promise.resolve(operationRes.bodyAsJson);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.listNextWithHttpOperationResponse(nextPageLink, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.bodyAsJson;
                return cb(err, result, data.request, data.response);
            });
        }
    }
}
exports.Operations = Operations;


/***/ })
/******/ ]);
//# sourceMappingURL=batchManagementClientBundle.js.map